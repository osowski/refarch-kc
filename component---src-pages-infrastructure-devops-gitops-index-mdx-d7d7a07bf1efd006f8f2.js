(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{"Yg8/":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return a})),n.d(t,"default",(function(){return b}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("q1tI");var r=n("7ljp"),o=n("013z");n("qKvR");function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var a={},c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(r.b)("div",t)}},s=c("InlineNotification"),p=c("PageDescription"),l={_frontmatter:a},u=o.a;function b(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(r.b)(u,i({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)(s,{kind:"warning",mdxType:"InlineNotification"},Object(r.b)("strong",null,"TODO")," - WORK IN PROGRESS"),Object(r.b)(p,{mdxType:"PageDescription"},"The implemented DevOps pipelines for the Reefer Container Shipment solution reference implementation of the Event-Driven Reference Architecture. This chapter focuses on the ",Object(r.b)("strong",null,"GitOps")," capability implemented in the reference implementation."),Object(r.b)("h1",null,"Overview"),Object(r.b)("p",null,"Our ",Object(r.b)("a",i({parentName:"p"},{href:"/refarch-kc/infrastructure/devops-continuous-integration/"}),"Continuous Integration (CI) approach")," is one of “zero-infrastructure overhead”. To accomplish this goal, we utilize ",Object(r.b)("a",i({parentName:"p"},{href:"https://github.com/features/actions"}),"GitHub Actions")," to build and push a microservice’s associated container images to ",Object(r.b)("a",i({parentName:"p"},{href:"https://hub.docker.com/u/ibmcase"}),"Docker Hub")," for public consumption. The GitHub Actions workflows are defined in the owning repository’s ",Object(r.b)("inlineCode",{parentName:"p"},".github/workflows/dockerbuild.yaml")," file."),Object(r.b)("p",null,"Our ",Object(r.b)("a",i({parentName:"p"},{href:"#gitops"}),"GitOps approach"),", ",Object(r.b)("em",{parentName:"p"},"the topic of this chapter"),", focuses on a single-repository, environment-per-subdirectory model which can be forked and cloned to replicate deployments to other clusters and environments. The reference implementation utilizes ",Object(r.b)("a",i({parentName:"p"},{href:"https://kustomize.io/"}),"Kustomize")," as its templating technology to utilize the ",Object(r.b)("inlineCode",{parentName:"p"},"app-deploy.yaml")," files, provided by each individual microservice, as a base and then layer in environment-specific configuration and credentials as needed."),Object(r.b)("p",null,"Our ",Object(r.b)("a",i({parentName:"p"},{href:"/refarch-kc/infrastructure/devops-continuous-delivery/"}),"Continuous Delivery (CD) approach")," focuses on a GitOps-based delivery model, using a GitHub repository as a single source of truth for the deployment, management, and operations of our running application components. In this model, we have the flexibility to use multiple open-source technologies to apply the single source of truth from a given GitHub repository onto a desired cluster environment."),Object(r.b)("h1",null,"GitOps"),Object(r.b)("p",null,"If you are unfamiliar with GitOps as a practice, additional details around the background of GitOps and how it differs from traditional deployment models can be found in ",Object(r.b)("a",i({parentName:"p"},{href:"https://www.weave.works/technologies/gitops/"}),"this blog post")," from WeaveWorks."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Sourced from ",Object(r.b)("a",i({parentName:"em"},{href:"https://github.com/ibm-cloud-architecture/refarch-kc-gitops/tree/starter-template"}),"https://github.com/ibm-cloud-architecture/refarch-kc-gitops/tree/starter-template"))),Object(r.b)("p",null,"The templated YAMLs are generated with the names of the required ConfigMaps and Secrets specific to a namespace on the eventual target deployment cluster. This allows us to create a deployment artifact programmatically without exposing confidential and secret credentials via source code."),Object(r.b)("p",null,"Once these YAMLs are generated, they are checked in to the main ",Object(r.b)("a",i({parentName:"p"},{href:"https://github.com/ibm-cloud-architecture/refarch-kc-gitops"}),"GitOps repository")," for the project, under a new branch with a branch name in the format of ",Object(r.b)("inlineCode",{parentName:"p"},"<namespace>/<cluster>")," for ease of identification. These will then have a folder structure of ",Object(r.b)("inlineCode",{parentName:"p"},"/<component-name>/templates/<artifact-type>.yaml"),", with most components providing Deployment, Service, and Route artifact YAMLs."),Object(r.b)("h2",null,"Environment overview"),Object(r.b)("h2",null,"Reference Implementation environments"),Object(r.b)("h2",null,"Creating a new environment"),Object(r.b)("h1",null,"Next steps"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"For details on how the Continuous Delivery implementation leverages the GitOps artifacts,")," reference the peer ",Object(r.b)("a",i({parentName:"p"},{href:"/refarch-kc/infrastructure/devops-continuous-delivery/"}),"Continuous Delivery (CD)")," chapter of this manual."))}b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-infrastructure-devops-gitops-index-mdx-d7d7a07bf1efd006f8f2.js.map